# JAVA_SYNTAX
## Variables 변수
- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름(식별자-Identifier)
- Mangaged Language: 자바는 개발자가 직접 메모리를 제어하지 못함. 직접 메모리 주소를 통해 값을 저장하고 참조할 필요 없이 변수를 통해 안전하게 값에 접근이 가능
- 식별자(변수명)는 변수의 값이 아닌 메모리 주소를 기억. 변수명을 사용하면 변수명과 매핑된 메모리 주소를 통해 메모리에 저장된 값을 반환
- 선언(deciaration): 변수명을 컴파일러에 알리는 행위
- 할당(assignment, 대입, 저장): 변수에 값을 저장하는 행위
- 참조(reference): 변수에 저장된 값을 읽어들이는 행위

### 변수 스코프
- 스코프: 변수에 접근하거나 접근할 수 있는 유효 범위. 일반적으로 변수가 선언된 블록 내.{}으로 구분.
- 라이프타임: 변수가 메모리 내에서 존재할 수 있는 시간.
```java
public class Sample {
    // 변수 선언
    int x, y;           // Instance Variable: 클래스 내부에 선언된 변수, main 메소드에 영향을 미치기 위해서는 인스턴스 선언이 필요.
    static int result;  // Class Variable: 클래스 내부에 선언된 static 변수
    
    void add(int a, int b){    // Local Variable이 매개변수(Parameter)로 활용
        // 변수에 값 할당
        x = a;
        y = b;
        int sum = x + y;    // 선언과 동시에 할당: 초기화
        System.out.println("Sum = "+sum);
    }

    public static void main(String[] args) {
        Sample obj = new Sample();  // 인스턴스 선언
        obj.add(10, 20);
    }
}

/*
 * Instance Variable
 *  - 클래스 내부와 모든 메소드 및 블록 위부에서 선언된 변수
 *  - scope: 정적 메소드를 제외한 클래스 전체
 *  - 라이프타임: 객체가 메모리에 존재할 때까지
 * 
 * Class Variable
 *  - 클래스 내부, 모든 외부 블로에서 선언되고 static으로 표시된 변수
 *  - scope: 클래스 전체
 *  - 라이프타임: 프로그램이 끝날 때까지
 *
 * Local Variable(지역변수)
 *  - 인스턴스 및 클래스 변수가 아닌 모든 변수
 *  - scope: 선언된 블록 내
 *  - 라이프타임: 컨트롤이 선언 된 블록을 떠날 때까지
 */
```

## 데이터 타입
### 타입의 종류
- 일반형(Primitive Type)
    - 정수형
        - int(기본): 32bit(4byte)
        - short: 16bit(2byte), 할당 할 시 s를 붙임.
        - byte: 8bit(1byte), 할당 할 시 b를 붙임.
        - long: 64bit(8byte), 할당 할 시 l를 붙임.
    - 실수형
        - float: 32bit(4byte), 할당 할 시 f를 붙임.
        - double(기본): 64bit(8byte)
    - 문자형
        - char: 16bit(2byte)
    - 논리형
        - Boolean: 8bite(1byte)
- 참조형(Reference Type)
    - 열거형
    - 클래스형
    - 인터페이스형

### 부동소수점(IEEE754 방식)
- 실수를 표현하기 위해 소숫점의 위치를 이동시키는 표현법

![img](images/image27.png)
![img](images/image28.png)
- 가수(Mantissa): 실제 값을 저장하는 부분
- 지수(Exponent): 실수의 크기를 표현하는 부호가 있는 정수
- 부호(Sign bit): 0이면 양수, 1이면 음수
- 2.74*10^14의 경우 가수=2.74, 지수=14, 부호는 0
- (예시) -314.625를 부동소수점으료 표현(float)
    1. 부호부: 음수이므로 32비트 가장 앞은 1
    ![img](images/image29.png)
    2. 가수부
        - 절댓값을 2진수로 표현 -> 100111010.101(2)
        - 소숫점 이동 -> 1.00111010101 * 2^8(2)
        - 소수점의 오른쪽 부분(00111010101)을 가수부 23비트의 앞에서부터 채우고 남은 자리는 0으로 채움.

        ![img](images/image31.png)
    3. 지수부
        - 지수 8에 bias인 127을 더함. = 135 = 10000111(2)
        - bias: 지수 부분의 음수와 양수를 구분하기 위해 더하는 2^(k-1)
        - k는 지수부의 비트수 8, double의 경우 11

        ![img](images/image33.png)

### 컴퓨터의 음수
- 음수: 양수와 더해서 0이되게 하는 값.
- 보수: 보충해 주는 수. 어떤 수 A가 B가 되기 위해 필요한 수
    - 예. 10진수 3의 10의 보수는 7.
- 2진수의 경우 2의 보수는 10(2)이 되는 값.
- 2의 보수 값을 더하게 되면 맨 왼쪽 비트가 1로 증가해 사라짐(Truncate), 다른 수는 모두 0.
- 앞에서 언급한 음수의 역할과 같다.
- 예. 10진수 3(이진수 11)을 4비트로 표현한 수 0011에 1101을 더하면 0000.
- 2진수를 모두 뒤집은 후에 1을 더하면 2진수에서 2의 보수를 만들 수 있다.

### 형 변환(Type Conversion)
- 데이터 타입이 다른 변수들 간의 연산 시 타입을 동일하게 바꾸는 것.
- 묵시적 형 변환(자동 형 변환)
    - 바이트 크기가 작은 자료형에서 큰 자료형으로 형 변환은 자동.
    - 덜 정밀한 자료형 -> 더 정밀한 자료형
    - 예. int iNum = 20; => float fNum = iNum;
- 명시적 형 변환(강제 형 변환)
    - 바이트 크기가 큰 자료형에서 작은 자료형으로 대입
    - 더 정밀한 자료형 -> 덜 정밀한 자료형
    - 예. int iNum = 1000; => byte bNum = (byte)iNum;
    - 위 예는 1000이 byte형 범위 -128~127 범위를 넘기 때문에 자료손실-> -24로 출력됨.

### 진법 변환 메소드
- 10진수 -> 2진수
    - Integer.toBinaryString(a)
    - Integer.toString(a, 2)
- 10진수 -> 8진수
    - Integer.toOctalString(a)
    - Integer.toString(a, 8)
- 10진수 -> 16진수
    - Integer.toHexString(a)
    - Integer.toString(a, 16)
- 2진수 -> 10진수
    - Integer.parseInt(a, 2)
- 8진수 -> 10진수
    - Integer.parseInt(a, 8)
- 16진수 -> 10진수
    - Integer.parseInt(a, 16)

## 연산자
### 연산자 종류
|구분|종류|
|-|-|
|대입 연산자|=|
|산술 연산자|+, -, *, /, %|
|증가/감소 연산자|++, --|
|관계 연산자|>, <, >=, <=, ==, !=|
|논리 연산자|&&, ||, !|
|복합 대입 연산자|+=, -=, *=, /=, &=. <<=, >>= >>>=, &=, !=, ^=|
|조건(삼항) 연산자|num = (5>3)? 10:20, ? 생략 가능|
|비트 논리 연산자|&, |, ^, ~|
|시프트 연산자|>>, <<, >>>|

### 연산자 우선순위
|우선순위|연산자|내용|
|-|-|-|
|1|(), []|괄호 / 대괄호|
|2|!, ~, ++, --|부정 / 증감 연산자|
|3|*, /, %|곱셈, 나눗셈 연산자|
|4|+, -|덧셈 / 뺄셈 연산자|
|5|<<, >>, >>>|비트단위의 쉬프트 연산자|
|6|<, <=, >, >=|관계 연산자|
|7|==, !=||
|8|&|비트단위의 논리 연산자|
|9|^||
|10|\|||
|11|&&|논리곱 연산자|
|12|\|\||논리합 연산자|
|13|?:|조건 연산자|
|14|=, +=, -=, *=, /=, %=, <<=, >>=, &=, ^=, ~=|대입 / 할당 연산자|
|15|i++, i--|뒤에 붙은 증감 연산자|

## 제어문
### 조건문
- if {}
- if {} else {}
- if {} else if {}
- switch / case

### 반복문 지시어
- for(시작; 조건; 증가) {}
- for(데이터타입:리스트)
- while(조건) {}
- do {} while(조건)

### 배열
- 데이터타입[] 변수명 = new 데이터타입[n]
- ex. int[] a = new int[5]
- 참조형의 경우는 선언 시 컴파일러에게 실행 때 무엇을 어떻게 해야한다는 지침만 기록.
- 실제로 메모리 공간이 확보되는 시점은 실행할 때.
- 배열 선언 예시
    - int[] a = new int[5]; => 선언 + 실행 시 할 행동
    - int[] a = new int[5]{1,2,3,4,5};  => 선언 + 행동 + 각 배열 요소 값 할당
    - int[] a = {1,2,3,4,5};
- 2차원 배열
    - int[][] b = { {1,2,3}, {4,5,6}, {7,8,9}}
    - int intArray[][] = new int[4][];

### final
- 선언 및 초기화 이후 Method Area에 저장
- 지역변수: 상수 선언(예: final int a = 3)
- 메서드: 오버라이딩 금지(예: public final void a(){})
- 클래스: 상속 금지(예: final class A{})
- 클래스 멤버변수: static 예약어 같이 사용(예: static final int a = 3)

## 객체와 클래스
- 객체(Object): 주체와 주체가 행하는 행위 일체
- => 객체지향 설계를 통해 객체를 캡슐화
    1. 객체를 정의
    2. 객체를 설계(UML)
    3. 코딩(Class)
    4. 객체지향 프로그래밍(OOP: Object Oriented Programming)
- 클래스(Object): 객체를 프로그래밍 코드로 정의
    - 멤버변수(전역변수): 주체의 속성을 변수로 정의
    - 메서드: 주체의 행위를 정의

### 접근 제한자
- 변수 및 객체(class, interface) 앞에 선언을 함으로서 외부 코드에서의 접근(사용) 범위를 통제.
- "정보 은닉"이라는 객체 지향 언어의 특성.
|종류|기능|
|-|-|
|public|모든 외부 코드에서 접근 가능|
|private|외부에서 클래스 변수에 직접 접근할 수 없고 클래스의 메서드를 통해서만 접근 가능. 상속받은 클래스에서도 접근 불가능|
|protected|외부에서는 변수에 직접 접근이 불가능. 상속받은 클래스에서는 가능|
|default(생략가능)|동일한 패키지 내의 클래스들만 접근 가능|

### static
- static으로 선언한 변수는 여러 인스턴스가 여려 변수 주소를 생성하는 것이 아니라 하나의 변수 주소를 공유한다.
- 값 변경 시 여러 인스턴스가 같이 바뀐다.
- static으로 선한된 메서드는 인스턴스 생성 없이 실행 가능

### 디자인 패턴
- [디자인패턴에 대한 정리](https://gmlwjd9405.github.io/2018/07/06/design-pattern.html)
- 싱글턴 패턴: 객체 지향 프로그램에서 인스턴스를 하나만 구현하는 방식
- 한 개의 파일에 하나의 클래스